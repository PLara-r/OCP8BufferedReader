# OCP8BufferedReader

1) Пример из репо
Классы BufferedReader и BufferedWriter


Давайте посмотрим на пример программы , которая использует как BufferedReaderи BufferedWriterклассы , использующие связанные с ним readLine()и write(String)методы. Он читает текстовый файл, выводит каждую строку на экран и записывает копию файла на диск. Поскольку эти классы буферизуются, вы можете ожидать лучшей производительности, чем если бы вы читали / писали каждый символ по одному.

import java.io.*;
import java.util.*;
public class CopyTextFileSample { 
  public static List<String> readFile(File source) throws IOException {  
    List<String> data = new ArrayList<String>();  
    try (BufferedReader reader = new BufferedReader(new FileReader(source))) {  
       String s;      
   while((s = reader.readLine()) != null) {     
       data.add(s);   
      }     
 }     
 return data; 
  }
public static void writeFile(List<String> data, File destination) throws    IOException {   
   try (BufferedWriter writer = new BufferedWriter(   
                new FileWriter(destination))) {   
      for(String s: data) {     
       writer.write(s);      
      writer.newLine();   
      }   
   }  
 }  
 public static void main(String[] args) throws IOException {  
    File source = new File("Zoo.csv");  
    File destination = new File("ZooCopy.csv"); 
     List<String> data = readFile(source);  
    for(String record: data) {   
      System.out.println(record);   
   }   
   writeFile(data,destination); 
  }}
Этот пример похож на пример копирования файла, который вы видели ранее, с некоторыми важными отличиями. Во-первых, в readFile()методе мы используем временную Stringссылку sдля хранения значения данных в цикле, когда мы их читаем. В отличие от FileInputStreamи FileReader, где мы использовали -1для проверки завершения файла intзначения BufferedReader, мы перестаем читать файл при readLine()возврате null.
Затем, вместо того , чтобы немедленно копировать данные мы читаем из файла в выходной файл, мы храним его в Listиз Stringобъектов в readFile()методе. Это позволяет нам отображать и изменять данные, прежде чем записать их на диск позже.
Например, предположим, что мы хотели заменить имя одного человека в текстовом файле другим. Мы просто использовали бы String.replaceAll()метод для данных, когда мы записывали их на диск, и новый файл имел бы замену. Работая полностью со Stringзначениями, а не со byteзначениями, мы имеем доступ ко всем методам StringAPI для манипулирования данными.
Последнее существенное различие между этим кодом и предыдущим примером файла копирования заключается в том, как данные записываются в writeFile()методе. В отличие от предыдущих примеров, где нам приходилось писать код по одному байту за раз или используя byteмассив, мы можем записать все целиком Stringза один вызов. write(String)Метод весьма удобен на практике. Затем мы используем метод writer.newLine (), чтобы вставить разрыв строки в скопированный файл, в то время как наш метод reader.readLine () разделяется на разрывы строк.
Обратите внимание, что мы использовали .csvрасширение файла в этом примере для представления файлов значений, разделенных запятыми, поскольку они обычно основаны на тексте. В этом примере также предполагается, что файл CSV достаточно мал, чтобы полностью поместиться в памяти.
Допустим, файл настолько большой, что не помещается в памяти. Если вы хотите записать его непосредственно на диск, а не хранить его в Listобъекте,
вы можете взять наш более ранний пример потока файлов копирования и заменить его на методы Reader/ Writer.

2)Расшифровка Java I/O имен классов

java.ioБиблиотека определяет четыре абстрактных классов, родители всех классов потоков , определенных в API: InputStream, OutputStream, Reader, и Writer. Для удобства авторы Java API включают имя абстрактного родительского класса в качестве суффикса дочернего класса. Например, ObjectInputStreamзаканчивается на InputStream, что означает, что он имеет InputStreamнаследуемый родительский класс. Хотя большинство потоковых классов java.ioследуют этому шаблону PrintStream, а это OutputStreamне так.
Конструкторы потоков высокого уровня часто ссылаются на абстрактный класс. Например, BufferedWriterпринимает Writerобъект в качестве входных данных, что позволяет ему принимать любой подкласс Writer.
Преимущество использования ссылки на абстрактный родительский класс в конструкторе класса должно быть очевидно в предыдущем примере потока высокого уровня. При использовании потоков высокого уровня класс может быть упакован несколько раз. Кроме того, разработчики могут определить свой собственный потокподкласс, который выполняет пользовательскую фильтрацию. Используя абстрактный родительский класс в качестве входных данных, потоковые классы высокого уровня можно использовать гораздо чаще, не обращая внимания на конкретный базовый подкласс потока.
Одной из общих областей, где экзамен любит подшучивать над тобой, является смешивание и сопоставление потоковых классов, которые не совместимы друг с другом. Например, посмотрите на каждый из следующих примеров и посмотрите, сможете ли вы определить, почему они не компилируются.


new BufferedInputStream(new FileReader("zoo-data.txt"));     // DOES NOT COMPILE
new BufferedWriter(new FileOutputStream("zoo-data.txt"));    // DOES NOT COMPILE
new ObjectInputStream(new FileOutputStream("zoo-data.txt")); // DOES NOT COMPILE
new BufferedInputStream(new InputStream());                  // DOES NOT COMPILE

Первые два примера не компилируются, потому что они смешивают Reader/ Writerклассы с InputStream/ OutputStreamклассами соответственно. Третий пример не компилируется, потому что мы смешиваем OutputStreamс InputStream. Хотя можно считывать данные из InputStreamи записывать в них OutputStream, перенос потока не является способом сделать это. Как вы увидите позже в этой главе, данные должны копироваться, часто итеративно. И, наконец, последний пример не компилируется , потому что InputStreamэто абстрактный класс, и поэтому вы не можете создать экземпляр экземпляра.  
Расшифровка Java I/O имен классов
Учитывая, что существует так много разных java.ioпотоковых классов, разумно подумать, что вы можете встретить на экзамене тот, чье имя вы, возможно, забыли. К счастью, функцию большинства потоковых классов можно понять, расшифровав имя класса. Мы суммируем эти свойства в следующем списке.
Обзор java.ioсвойств класса
•	Класс со словом InputStreamили OutputStreamв его названии используется для чтения или записи двоичных данных соответственно.
•	Класс со словом Readerили Writerв его названии используется для чтения или записи символьных или строковых данных соответственно.
•	Большинство, но не все, входные классы имеют соответствующий выходной класс.
•	Низкоуровневый поток напрямую связан с источником данных.
•	Поток высокого уровня создается поверх другого потока с использованием переноса.
•	Класс со Bufferedсвоим именем читает или записывает данные в виде групп байтов или символов и часто повышает производительность в последовательных файловых системах.
При переносе потока вы можете смешивать и сопоставлять только те типы, которые наследуются от одного и того же абстрактного родительского потока.
Таблица 8.2 описывает те java.ioпотоки, с которыми вы должны быть знакомы на экзамене. Обратите внимание, что большая часть информации о каждом потоке, например, является ли он входным или выходным потоком или получает ли он доступ к данным, используя байты или символы, может быть декодирована только по имени.
Таблица 8.2 .java.ioКлассы потоков

Class Name	Low/High Level	Описание
InputStream	N/A	Абстрактный класс, который InputStreamнаследуют все классы
OutputStream	N/A	Абстрактный класс, который OutputStreamнаследуют все классы
Reader	N/A	Абстрактный класс, который Readerнаследуют все классы
Writer	N/A	Абстрактный класс, который Writerнаследуют все классы
FileInputStream	Low	Читает данные файла как байты
FileOutputStream	Low	Записывает данные файла в байтах
FileReader	Low	Читает данные файла как символы
FileWriter	Low	Записывает данные файла в виде символов
BufferedReader	High	Считывает символьные данные из существующего Readerв буферизованном виде, что повышает эффективность и производительность
BufferedWriter	High	Записывает символьные данные в существующий Writerв буферизованном виде, что повышает эффективность и производительность
ObjectInputStream	High	Десериализует примитивные типы данных Java и графики объектов Java из существующего InputStream
ObjectOutputStream	High	Сериализует примитивные типы данных Java и графики объектов Java в существующий OutputStream
InputStreamReader	High	Читает символьные данные из существующего InputStream
OutputStreamWriter	High	Записывает данные персонажа в существующий OutputStream
PrintStream	High	Записывает отформатированные представления объектов Java в двоичный поток
PrintWriter	High	Записывает отформатированные представления объектов Java в поток вывода на основе текста

Мы обсудим эти java.ioклассы более подробно, включая примеры в следующих разделах. 

3) Операции общего потока
 рассмотрим некоторые общие процессы(методы) при работе с потоками.
  


  Закрытие потока
Поскольку потоки считаются ресурсами, крайне важно, чтобы они были закрыты после их использования, чтобы не привести к утечке ресурсов. Как вы видели в главе 6 «Исключения и утверждения», это можно сделать, вызвав close()метод в finallyблоке или используя синтаксис try-with-resource.
В файловой системе неправильное закрытие файла может оставить его заблокированным операционной системой, так что никакие другие процессы не смогут прочитать / записать его, пока программа не будет завершена. В этой главе мы будем закрывать потоковые ресурсы, используя синтаксис try-with-resource, поскольку это предпочтительный способ закрытия ресурсов в Java. 
 Промывка ручья
Когда данные записываются в OutputStream, базовая операционная система не обязательно гарантирует, что данные сразу попадут в файл. Во многих операционных системах данные могут кэшироваться в памяти, при этом запись происходит только после заполнения временного кэша или по прошествии некоторого времени.
Если данные кэшируются в памяти и приложение неожиданно завершает работу, данные будут потеряны, поскольку они никогда не записывались в файловую систему. Для решения этой проблемы Java предоставляет flush()метод, который запрашивает немедленную запись всех накопленных данных на диск.
Этот flush()метод помогает уменьшить объем потерянных данных, если приложение неожиданно завершает работу. Это не без стоимости, хотя. Каждый раз, когда он используется, это может вызвать заметную задержку в приложении, особенно для больших файлов. Если данные, которые вы пишете, не являются чрезвычайно важными, flush()метод следует использовать только периодически. Например, он не обязательно должен вызываться после каждой записи, но после каждой дюжины записей или около того, в зависимости от ваших требований. Для относительно небольших файлов вам может понадобиться позвонить flush()только один раз.
Вам не нужно вызывать flush()метод явно, когда вы закончите запись в файл, так как close()метод сделает это автоматически. В некоторых случаях вызов flush()метода периодически во время записи большого файла, а не выполнение одной большой очистки при закрытии файла, может улучшить производительность за счет расширения доступа к диску в ходе процесса записи.  
Маркировка потока
InputStreamИ Readerклассы включают в себя mark(int)и reset()методы для перемещения потока назад к более ранней позиции. Перед вызовом любого из этих методов вы должнывызовите markSupported()метод, который возвращает trueтолько если mark()поддерживается. Не все java.ioвходные потоки поддерживают эту операцию, и попытка вызова mark(int)или reset()для класса, который не поддерживает эти операции, вызовет исключение во время выполнения.
Убедившись, что поток может поддерживать эти операции, вы можете вызывать mark(int)с предельным значением для чтения. Затем вы можете прочитать столько байтов, сколько захотите, вплоть до предельного значения. Если в какой-то момент вы захотите вернуться к более ранней позиции, где вы в последний раз звонили mark(), тогда вы просто позвоните, reset()и поток «вернется» в более раннее состояние. На практике это не фактическая передача данных обратно в поток, а сохранение уже прочитанных данных в памяти для последующего чтения. Поэтому не следует вызывать mark()операцию со слишком большим значением, так как это может занять много памяти.
Предположим, что у нас есть InputStreamэкземпляр, следующие значения которого ABCD. Рассмотрим следующий фрагмент кода:

InputStream is = . . .
System.out.print ((char)is.read());
if(is.markSupported()) { 
  is.mark(100);
   System.out.print((char)is.read());
   System.out.print((char)is.read());  
 is.reset()
;}
System.out.print((char)is.read());
System.out.print((char)is.read());
System.out.print((char)is.read());

Фрагмент кода выведет следующее, если mark()операция поддерживается:

ABCBCD
Это сначала выводит Aперед if/thenутверждением. Так как нам дано , что поток поддерживает mark()операцию, он будет ввести if/thenзаявление и прочитать два символа BC. Затем он вызывает reset()операцию, переводя наш поток обратно в состояние, в котором он находился после Aчтения, поэтому BCснова считывается и затем D.
Если  mark()операция не поддерживается, она выведет это вместо этого, полностью пропустив if/thenоператор:

ABCD
Обратите внимание, что независимо от того, mark()поддерживается ли операция, мы позаботились о том, чтобы конец потока находился в одной и той же позиции.
Наконец, если вы позвоните reset()после того, как превысили mark()лимит чтения, во время выполнения может возникнуть исключение, поскольку помеченная позиция может стать недействительной. Мы говорим « может быть сгенерировано исключение », поскольку некоторые реализации могут использовать буфер, чтобы разрешить чтение дополнительных данных до того, как метка станет недействительной.  
Пропуск данных
InputStreamИ Readerклассы также включают в себя skip(long)метод, который , как вы могли бы ожидать скачет за определенное число байтов. Возвращает longзначение, которое указывает количество фактически пропущенных байтов. Если возвращаемое значение равно нулю или отрицательно, например, если достигнут конец потока, байты не пропускаются.
Предположим, что у нас есть InputStreamэкземпляр, следующие значения которого TIGERS. Рассмотрим следующий фрагмент кода:
InputStream is = . . .
System.out.print ((char)
is.read());
is.skip(2)is.read();
System.out.print((char)is.read());
System.out.print((char)is.read());
Код будет читать один символ, Tпропустить два символа, IGа затем прочитать еще три символа ERS, только последние два из которых будут напечатаны пользователю, что приведет к следующему выводу.

TRS
В этом примере вы можете заметить, что вызов skip()операции эквивалентен вызову read()и отбрасыванию вывода. Для пропуска горстки байтов практически нет разницы. С другой стороны, пропуск большого количества байтов skip()часто будет быстрее, поскольку он будет использовать массивы для чтения данных.





